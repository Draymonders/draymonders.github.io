## 单机锁

### 可重入锁 / 不可重入

使用 `ReentrantLock` 获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态 +1 ,释放锁的时候则将状态 -1。只有将同步状态的次数置为 0 的时候才会最终释放锁。

### 共享锁 / 读写锁 

使用 `ReentrantReadWriteLock` ,同时维护一对锁：读锁和写锁。当写线程访问时则其他所有锁都将阻塞，读线程访问时则不会。通过读写锁的分离可以很大程度的提高并发量和吞吐量。


## 分布式锁

业界常用的解决方案通常是借助于一个第三方组件并利用它自身的排他性来达到多进程的互斥。

### 基于数据库

可以创建一张表，将其中的某个字段设置为`唯一索引`，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。

存在的问题:

- 数据库单点问题，挂了怎么办？
- 不是重入锁，同一进程无法在释放锁之前再次获得锁，因为数据库中已经存在了一条记录了。
- 锁是非阻塞的，一旦 `insert` 失败则会立即返回，并不会进入阻塞队列只能下一次再次获取。
- 锁没有失效时间，如果那个进程解锁失败那就没有请求可以再次获取锁了。

解决方案:

- 数据库切换为主从，不存在单点。
- 在表中加入一个同步状态字段，每次获取锁的是加 1 ，释放锁的时候`-1`，当状态为 0 的时候就删除这条记录，即释放锁。
- 非阻塞的情况可以用 `while` 循环来实现，循环的时候记录时间，达到 X 秒记为超时，`break`。
- 可以开启一个定时任务每隔一段时间扫描找出多少 X 秒都没有被删除的记录，主动删除这条记录。

### 基于 Redis

同时使用 `set key value [EX seconds] [PX milliseconds] [NX|XX]` 当key不存在才插入，超过`PX`ms就会remove

存在的问题

- 阻塞(一定的时间内没拿到锁一直等待)如何实现
- `master`down掉，`slave`还没接收到数据，怎么办
- 当任务执行时间长，key因超时删除了怎么办

解决方案

- 类似CAS，循环获取锁的状态，当`超时`or`获取到锁`再退出循环
- [Redlock算法](https://blog.brickgao.com/2018/05/06/distributed-lock-with-redlock/)
    * 客户端会记录所有实例返回加锁成功的时间，只有从**多半**的实例获取到了锁，且操作的时间远小于分布式锁的超时时间，锁才被人为是正确获取。
- 获取到锁后，新开线程做保活，判断 `(key, value)`的value是当前进程生成的，如若是，增加`expire time`, 当`超时`或`value不是当前进程生成的`就退出线程。
