- JVM内存模型
    * 程序计数器，线程私有，当前线程执行字节码的行号指示器
    * Java虚拟机栈，线程私有，**记录方法执行的内存模型**，栈帧（存储局部变量表、操作数栈、动态连接、方法出口）
    * 本地方法栈，native方法，线程私有
    * Java堆，线程共享，`-Xmx -Xms`
    * 方法区，线程共享，**存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**
- 垃圾分析算法
    * 引用计数法
    * 可达性分析
        * 虚拟机栈中引用的对象
        * 方法区静态属性引用的对象
        * 方法区常量引用的对象
        * JNI(Native)引用的对象
        * 被同步锁持有的对象
- 四种引用
    * 强引用,软引用(快OOM时GC),弱引用(下一次GC)，虚引用
* 名词解释
    * 新生代收集（Minor GC/Young GC）,指目标只是新生代的垃圾收集
    * 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
    * 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集
- 垃圾收集算法
    * 标记清除(1. 效率随对象数增多而变低; 2. 内存碎片化高)
    * 标记复制(要清除的对象多的情况下，效率高)
    * 标记整理
- 枚举根节点时也是必须要停顿的，保证一致性
- 垃圾收集器
    * CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器(老年代收集器)
        1）初始标记（CMS initial mark）
        2）并发标记（CMS concurrent mark）
        3）重新标记（CMS remark）
        4）并发清除（CMS concurrent sweep）
    * Garbage First（简称G1）收集器
        - G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。
        - 每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region
        * 初始标记
        * 并发标记
        * 最终标记
        * 筛选回收
- 分代回收
- CMS和G1的区别
- 双亲委派是用组合方式，不是用继承方式
    * 可以想到的是，如果是继承方式，那么相当于会执行多态，从而无法达到预期的双亲委派的目的